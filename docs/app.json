[{"name": "app.py", "content": "from shiny import App, ui, render, reactive\nimport gpxpy\nimport gpxpy.gpx\nimport xml.etree.ElementTree as ET\nimport matplotlib.pyplot as plt\nimport datetime\nimport io\nimport folium\n\n# Define a list of contrasting colors\nCONTRASTING_COLORS = ['#FF0000', '#00FF00', '#0000FF', '#FF00FF', '#00FFFF', '#FFFF00', '#800000', '#008000', '#000080', '#800080']\n\napp_ui = ui.page_fluid(\n    ui.panel_title(\"TCX Data Viewer\"),\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_file(\"tcx_files\", \"Upload TCX file(s)\", accept=[\".tcx\"], multiple=True),\n            ui.output_ui(\"file_info\"),\n        ),\n        ui.column(6,\n            ui.output_ui(\"map_output\"),\n        ),\n        ui.column(6,\n            ui.output_plot(\"heart_rate_plot\"),\n        ),\n    )\n)\n\ndef server(input, output, session):\n    \n    tcx_data = reactive.Value({})\n    \n    @reactive.Effect\n    @reactive.event(input.tcx_files)\n    def _():\n        files = input.tcx_files()\n        if files is None:\n            tcx_data.set({})\n            return\n        \n        processed_data = {}\n        for i, file in enumerate(files):\n            file_content = file[\"datapath\"]\n            try:\n                with open(file_content, \"r\") as f:\n                    tcx_content = f.read()\n                gpx, heart_rates, start_time, duration = convert_tcx_to_gpx(tcx_content)\n                max_hr = max(heart_rates) if heart_rates else 0\n                processed_data[file[\"name\"]] = {\n                    \"gpx\": gpx,\n                    \"heart_rates\": heart_rates,\n                    \"start_time\": start_time,\n                    \"duration\": duration,\n                    \"max_hr\": max_hr,\n                    \"color\": CONTRASTING_COLORS[i % len(CONTRASTING_COLORS)]\n                }\n            except Exception as e:\n                print(f\"Error processing TCX data for {file['name']}: {str(e)}\")\n                processed_data[file[\"name\"]] = {\"error\": f\"Error processing TCX data: {str(e)}\"}\n        \n        tcx_data.set(processed_data)\n\n    @output\n    @render.ui\n    def file_info():\n        data = tcx_data.get()\n        if not data:\n            return \"Please upload TCX file(s).\"\n        \n        info_html = \"<h3>Data Information:</h3>\"\n        for filename, file_data in data.items():\n            if \"error\" in file_data:\n                info_html += f\"<p><strong>{filename}:</strong> Error: {file_data['error']}</p>\"\n            else:\n                info_html += f\"<p><strong>{filename}:</strong><br>\"\n                info_html += f\"Date: {file_data['start_time'].strftime('%Y-%m-%d %H:%M:%S')}<br>\"\n                info_html += f\"Duration: {str(file_data['duration']).split('.')[0]}<br>\"\n                info_html += f\"Maximum Heart Rate: {file_data['max_hr']} bpm</p>\"\n        \n        return ui.HTML(info_html)\n\n    @output\n    @render.ui\n    def map_output():\n        data = tcx_data.get()\n        if not data:\n            return \"No map data available\"\n        \n        # Create a folium map centered on the first point of the first file\n        first_file = next(iter(data.values()))\n        if \"error\" in first_file:\n            return \"No valid map data available\"\n        \n        first_points = get_points(first_file['gpx'])\n        if not first_points:\n            return \"No valid GPS points found\"\n        \n        m = folium.Map(location=first_points[0], zoom_start=12)\n        \n        for filename, file_data in data.items():\n            if \"error\" not in file_data:\n                points = get_points(file_data['gpx'])\n                if points:\n                    # Add the track as a polyline\n                    folium.PolyLine(points, color=file_data['color'], weight=2.5, opacity=0.8, popup=filename).add_to(m)\n                    \n                    # Add markers for start and end points\n                    folium.Marker(points[0], popup=f\"Start - {filename}\", icon=folium.Icon(color='green', icon='play')).add_to(m)\n                    folium.Marker(points[-1], popup=f\"End - {filename}\", icon=folium.Icon(color='red', icon='stop')).add_to(m)\n        \n        # Convert the map to HTML\n        map_html = m._repr_html_()\n        \n        # Wrap the map HTML in a div with a fixed height and width\n        return ui.HTML(f\"<div style='height: 400px; width: 100%;'>{map_html}</div>\")\n\n    @output\n    @render.plot\n    def heart_rate_plot():\n        data = tcx_data.get()\n        if not data:\n            return None\n        \n        fig, ax = plt.subplots(figsize=(10, 6))\n        \n        for filename, file_data in data.items():\n            if \"error\" not in file_data:\n                time_labels = [str(datetime.timedelta(seconds=s)) for s in range(int(file_data['duration'].total_seconds()) + 1)]\n                ax.plot(time_labels[:len(file_data['heart_rates'])], file_data['heart_rates'], color=file_data['color'], label=filename)\n        \n        ax.set_xlabel(\"Time (hours:minutes:seconds)\")\n        ax.set_ylabel(\"Heart Rate (bpm)\")\n        ax.set_title(\"Heart Rate Over Time\")\n        \n        plt.xticks(rotation=45, ha='right')\n        \n        # Show only a subset of x-axis labels to avoid overcrowding\n        num_ticks = 10\n        tick_indices = [i for i in range(0, len(time_labels), len(time_labels) // num_ticks)]\n        plt.xticks(tick_indices, [time_labels[i] for i in tick_indices])\n        \n        plt.legend()\n        plt.tight_layout()\n        return fig\n\ndef convert_tcx_to_gpx(tcx_content):\n    def parse_xml(content):\n        return ET.fromstring(content)\n\n    try:\n        tcx_root = parse_xml(tcx_content)\n    except ET.ParseError as e:\n        raise ValueError(f\"Unable to parse TCX data. Error: {str(e)}. Data starts with: {tcx_content[:100]}\")\n\n    gpx = gpxpy.gpx.GPX()\n    track = gpxpy.gpx.GPXTrack()\n    gpx.tracks.append(track)\n    segment = gpxpy.gpx.GPXTrackSegment()\n    track.segments.append(segment)\n\n    namespace = {'ns': 'http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2'}\n    \n    heart_rates = []\n    start_time = None\n    end_time = None\n    \n    for trackpoint in tcx_root.findall('.//ns:Trackpoint', namespace):\n        time = trackpoint.find('ns:Time', namespace)\n        lat = trackpoint.find('ns:Position/ns:LatitudeDegrees', namespace)\n        lon = trackpoint.find('ns:Position/ns:LongitudeDegrees', namespace)\n        hr = trackpoint.find('ns:HeartRateBpm/ns:Value', namespace)\n        \n        if time is not None:\n            current_time = datetime.datetime.fromisoformat(time.text)\n            if start_time is None:\n                start_time = current_time\n            end_time = current_time\n        \n        if lat is not None and lon is not None:\n            point = gpxpy.gpx.GPXTrackPoint(\n                latitude=float(lat.text),\n                longitude=float(lon.text)\n            )\n            segment.points.append(point)\n        \n        if hr is not None:\n            heart_rates.append(int(hr.text))\n\n    if not segment.points:\n        raise ValueError(\"No valid GPS points found in the TCX data\")\n\n    duration = end_time - start_time if start_time and end_time else datetime.timedelta()\n    return gpx, heart_rates, start_time, duration\n\ndef get_points(gpx):\n    points = []\n    for track in gpx.tracks:\n        for segment in track.segments:\n            for point in segment.points:\n                points.append((point.latitude, point.longitude))\n    return points\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "README.md", "content": "# 2024_scgis_tcx_pyodide\n\ntest", "type": "text"}, {"name": "requirements.txt", "content": "shiny\ngpxpy\nmatplotlib\nfolium\nbranca\nrequests\nxyzservices", "type": "text"}]